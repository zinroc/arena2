rromise = Promise || require("bluebird");

var utils = require("../utils.js");

var popCap = 100;
/**
 * Interacts with character state
 * Requires knex when loaded
 */
module.exports = function (knex) {
    this.knex = knex;

    return {
        /**
        *   Called by client
        */
        getEncounterInfo: function(email, encounter){
            //Want to know encunter elder
        },
        /**
        *   Called by client
        */
        getElders: function (region){
            return knex("elders")
            .select("*")
            .where({region: region})
            .then(function (rows){
                return rows;
            });
        },
        /**
        *   Called by client
        *   Generate an encounter for a character
        */  
        generateEncounter: function (email, char_id, elder_id, encounter_name){
            return knex("characters")
            .select("*")
            .where({owner: email, id: char_id})
            .then(function (rows){
                if (rows.length !== 1){//error
                    return false;
                } else {
                    return rows[0];
                }
            }).then(function (character){
                if (!character){ //error
                    return false;
                } else {
                    //get 9 unique random cards and a random seed
                    var cards = utils.getNineCards();
                    var seed = utils.getRandomSeed();
                    cards.seed = seed;
                    return cards;
                }
            }).then(function (cards){
                //place cards in DB
                if(!cards){
                    return false;
                } else {
                    return knex("encounters")
                        .insert({card_1: cards[0], card_2: cards[1], card_3: cards[2], card_4: cards[3], card_5: cards[4], elder_id: elder_id, encounter_name: encounter_name})
                        .returning("id")
                        .then(function (encounter_id){
                            cards.id = encounter_id;
                            return cards;
                        });
                }
            }).then(function (cards){
                // give cards to the player
                if (!cards){
                    return false;
                } else {
                    cards.id = parseInt(cards.id);
                    char_id = parseInt(char_id);

                    return knex("encounter_characters")
                    .insert({encounter: cards.id, character: char_id, card_1: cards[5], card_2: cards[6]})
                    .then(function (){
                        return cards;
                    });
                }
            }).then(function (cards){
                if(!cards){
                    return false;
                } else {
                    //update the character entry locking into encounter
                    return knex("characters")
                    .where({owner: email, id: char_id})
                    .update("encounter", cards.id)
                    .then(function (){
                        return cards;
                    });
                }
            }).then(function (cards){
                //give cards to the opponent
                if(!cards){
                    return false;
                } else {
                    return knex("encounter_elders")
                    .insert({encounter: cards.id, elder: elder_id, card_1: cards[7], card_2: cards[8]})
                    .then(function(){
                        return cards;
                    })
                }
            }).then(function (cards){
                if(cards){
                    return true;
                } else {
                    return false;
                }
            });
        },
        /**
        * Get characterInfo
        * currently not called
        */
        get: function (){
            return knex("characters")
            .select("*")
            .then(function (rows){
                return rows;
            });
        },
        /**
        * Get characterInfo
        * currently called from client
        */
        getPlayerCharacters: function (email){
            return knex("characters")
            .where("owner", email)
            .select("*")
            .then(function (rows){
                return rows;
            });
        },
        /**
        * Create a character
        * Called from server.
        */
        create: function (name){
            return knex("characters")
            .insert({name: name, bot: true})
            .returning("id")
            .then(function (rows){
                return rows[0];
            });
        },
        /**
        * Create a character owned by a player
        * STRING name
        * Called from client
        */
        createPlayerCharacter: function (email, name, family_name){
            return knex("characters")
            .insert({name: name, family_name: family_name, owner: email})
            .returning("id")
            .then(function (rows){
                return rows[0];
            });
        },
        /**
        * Delete a character owned by a player
        * INT id from characters(id)
        * Called from client
        */
        deletePlayerCharacter: function (email, id){
            return knex("characters")
            .where({owner: email, id: id})
            .update({encounter: null})
            .then(function (characters){
                var character = characters[0];
                return knex("encounter_characters")
                .where({character: id})
                .del();
            }).then(function (){
                return knex("characters")
                .where({owner: email, id: id})
                .del();
            }).then(function (){
                return true;
            });
        },
        /**
        * Spawn a character owned by a player into a location
        * INT id from characters(id)
        *  STRING location 
        * Called from client
        * Called from server when characters traveling
        */
        spawnPlayerCharacter: function (email, id, location){
            return knex("characters")
            .where({owner: email, id: id})
            .update({location: location})
            .then(function (){
                return true;
            });
        },
        /*
        * Called from server.
        * supplies a regular population to the world.
        */
        createPop: function (){
            return this.get()
            .then(function (characterArr){
                var charactersForCreation = popCap - characterArr.length;
                var promises = [];
                for (var i=0; i<charactersForCreation; i++){
                    var name = utils.newName();
                    var characterStore = require("./characterStore.js")(knex);
                    promises[i] = characterStore.create(name);
                }
                return Promise.all(promises);
            }).then(function (ids){
                return ids;
            });
        },
        /**
        *   Called by server
        *  Called every timestep
        */
        arriveAtDestination: function (){
            return knex("characters")
            .whereRaw('destination = location')
            .update({destination: null, direction: null, travel_success: null, travel_progress: null})
            .then(function (){
                return true;
            });
        },
        /**
        *   Called by server
        *   Called every tmestep
        *   currently all travelers are successful
        */
        findSuccessfulTravelers: function (){
            return knex("characters")
            .whereNotNull("destination")
            .update({travel_success: 'true'})
            .then(function(){
                return true;
            });
        },
        /**
        *   Called by server
        *   Called every new timestep
        */
        moveTravelers: function (){
            return knex("regions")
            .then(function (regionsArr){
                var promises = [];
                for (var i=1; i<regionsArr.length-1; i++){//edge case at regionArr[0] going west and regionsArr[max] going east
                    var promiseIndex = i-1; 
                    var eastRegion = regionsArr[i+1];
                    var region = regionsArr[i];
                    promises[promiseIndex] = knex("characters") // move characters east
                                                .where({location: region.name, direction: 'east', travel_success: 'true'})
                                                .update({location: eastRegion.name, travel_success: null});
                                            
                }

                for (var j=1; j<(regionsArr.length-1); j++) {
                    promiseIndex++; 
                    var westRegion = regionsArr[j-1];
                    var region = regionsArr[j]; 
                    promises[promiseIndex] = knex("characters") // move characters west
                                                .where({location: region.name, direction: 'west', travel_success: 'true'})
                                                .update({location: westRegion.name, travel_success: null});
                                        

                }

                //edgecase of regionsArr[0] moving west (and east)
                promiseIndex ++; 
                eastRegion = regionsArr[1];
                westRegion =regionsArr[regionsArr.length-1];
                region = regionsArr[0]; 

                promises[promiseIndex] = knex("characters") //catch characters at region[0] moving west
                                            .where({location: region.name, direction: 'west', travel_success: 'true'})
                                            .update({location: westRegion.name, travel_success: null}); 
                                        
                promiseIndex++;

                promises[promiseIndex] = knex("characters")//catch characters at region[0] moving east
                                            .where({location: region.name, direction: "east", travel_success: 'true'})
                                            .update({location: eastRegion.name, travel_success: null});
                                        
                promiseIndex++;

                eastRegion = regionsArr[0]; 
                westRegion = regionsArr[regionsArr.length-2];
                region = regionsArr[regionsArr.length-1];

                promises[promiseIndex] = knex("characters")//catch characters at region[max] moving west
                                            .where({location: region.name, direction: 'west', travel_success: 'true'})
                                            .update({location: westRegion.name, travel_success: null}); 
                                        
                promiseIndex++;

                promises[promiseIndex] = knex("characters")//catch characters at region[max] moving east
                                          .where({location: region.name, direction: "east", travel_success: 'true'})
                                          .update({location: eastRegion.name, travel_success: null});
                                    

                return Promise.all(promises);
            }).then(function (){
                return true;
            });
        },
        /**
        * Called from client
        *   @params email STRING
        *   @params id INT refrences characters(id)
        *   @params destination STRING
        */
        travel: function (email, id, destination, direction){
            return knex("characters")
            .where({owner: email, id: id}) 
            .whereNot({location: destination}) // make sure you are not traveling to current location
            .update({destination: destination, travel_progress: 0, direction: direction})
            .then(function () {
                return true;
            });
        }

    };
};